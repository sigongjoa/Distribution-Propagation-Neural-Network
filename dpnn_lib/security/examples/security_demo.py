import torch
from dpnn_lib.security.security_cell import SecurityCell
from dpnn_lib.security.watermark import WatermarkManager
from dpnn_lib.security.crypto import HEManager
import tenseal as ts

# Define common parameters
input_shape = (8, 16) # Example input shape for the base cell
correct_watermark_id = "model-v1"
secret_key = "my_super_secret_key"

# 1) Define a base cell
base = torch.nn.Linear(input_shape[-1], input_shape[-1]) # Adjust for last dimension

# 2) 보안 셀로 래핑 (ID = "model-v1")
sec_cell = SecurityCell(base, watermark_id=correct_watermark_id, input_shape=input_shape, secret_key=secret_key)

# Initialize managers
wm_correct = WatermarkManager(correct_watermark_id, secret_key=secret_key)
he = HEManager()

# Prepare a plain input tensor
x_plain = torch.randn(input_shape, dtype=torch.float32)

# --- Scenario 1: Forward pass with correct watermark and encryption ---
print("\n--- Scenario 1: Forward pass with correct watermark and encryption ---")

# SecurityCell now handles embedding and encryption internally
y_encrypted_output = sec_cell(x_plain)

# Decrypt the final output for verification and inspection
y_decrypted_flat = he.decrypt(y_encrypted_output)
y_decrypted_reshaped = y_decrypted_flat.reshape(input_shape)

print("SecurityCell PoC OK, output shape:", y_decrypted_reshaped.shape)

# Verify the watermark on the decrypted output using the correct WatermarkManager
assert wm_correct.verify(y_decrypted_reshaped, input_shape, correct_watermark_id), "Output watermark verification failed!"
print("Output watermark successfully verified with correct ID.")

# --- Scenario 2: Test with an invalid watermark ID (conceptual) ---
print("\n--- Scenario 2: Test with an invalid watermark ID (conceptual) ---")

# To simulate an invalid watermark, we'll try to verify the output
# with a WatermarkManager initialized with a different ID.
wm_invalid = WatermarkManager("invalid-id", secret_key=secret_key)

try:
    print("Attempting to verify output with an invalid watermark ID...")
    # This should fail because the watermark pattern generated by wm_invalid
    # will not match the one embedded by wm_correct.
    assert not wm_invalid.verify(y_decrypted_reshaped, input_shape, "invalid-id"), "Verification passed with invalid ID unexpectedly!"
    print("SUCCESS: Verification with invalid ID correctly failed.")
except AssertionError as e:
    print(f"FAILURE: Unexpected assertion: {e}")
except Exception as e:
    print(f"Caught unexpected error: {e}")

# --- Scenario 3: Test with tampered plaintext input (conceptual) ---
print("\n--- Scenario 3: Test with tampered plaintext input (conceptual) ---")

# Create a tampered plaintext input (without embedding watermark first)
# This simulates an attacker tampering with the input before it reaches SecurityCell
x_tampered_plain = x_plain.clone()
x_tampered_plain[0, 0] += 100.0 # Introduce a significant change

try:
    print("Attempting to process tampered plaintext input...")
    # The SecurityCell will embed its own watermark, but the underlying data
    # is tampered. The watermark verification on the output should still pass
    # if the watermark is robust to small changes, but fail if the change is large.
    # For this PoC, the watermark is added as noise, so large tampering might
    # make the correlation too low.
    y_encrypted_tampered_output = sec_cell(x_tampered_plain)
    y_decrypted_tampered_reshaped = he.decrypt(y_encrypted_tampered_output).reshape(input_shape)
    
    # The assertion here depends on the watermark's robustness. If the watermark
    # is designed to detect *any* change, this should fail. Our current simple
    # noise-based watermark might not be robust enough for this specific test.
    # For a true tamper-detection, the watermark would need to be more sophisticated.
    # For now, we expect it to pass if the watermark is still detectable despite tampering.
    # A more robust watermark would fail here.
    print("Watermark verification on tampered input output (expected to pass if watermark is robust to tampering, fail otherwise).")
    assert wm_correct.verify(y_decrypted_tampered_reshaped, input_shape, correct_watermark_id), "Watermark verification failed on tampered input!"
    print("SUCCESS: Watermark still detected on tampered input (implies robustness or insufficient tampering).")
except AssertionError as e:
    print(f"FAILURE: Watermark correctly failed on tampered input: {e}")
except Exception as e:
    print(f"Caught unexpected error: {e}")